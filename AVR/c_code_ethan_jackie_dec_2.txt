#include <avr/io.h>
#include <avr/interrupt.h>
#include <stdlib.h>
#include <string.h>
#include <avr/io.h>
#include <avr/pgmspace.h>
#include <util/atomic.h>
#include <util/delay.h>
#include <compat/twi.h>

#include "delay.h"
#include "i2c.h"

#define MAX_TRIES 50

// Used to initialize the I2C module
void I2C_Init()
{
    TWSR=0x00; // set presca1er bits to 1 (0x00=1, 0x01=4, 0x02=16, 0x03=64)
    TWBR=0x00; // SCL frequency is 10K for 1Mhz; for now I'm not sure if this is optimal CHAD 0x2A
    //TWCR=0x04; // enab1e TWI module, sets TWEN to high
}


/***************************************************************************************************

 * description  :This function is used to generate I2C Start Condition.
                 Start Condition: SDA goes low when SCL is High.

                               ____________
                SCL:          |            |
                      ________|            |______
                           _________
                SDA:      |         |
                      ____|         |____________

 ***************************************************************************************************/
void I2C_Start()
{
    TWCR = ((1<<TWINT) | (1<<TWSTA) | (1<<TWEN));
    while (!(TWCR & (1<<TWINT)))
		;
}

/***************************************************************************************************

 * description  :This function is used to generate I2C Stop Condition.
                 Stop Condition: SDA goes High when SCL is High.

                               ____________
                SCL:          |            |
                      ________|            |______
                                 _________________
                SDA:            |
                      __________|

 ***************************************************************************************************/

void I2C_Stop(void)
{
    TWCR = ((1<< TWINT) | (1<<TWEN) | (1<<TWSTO));
    _delay_us(100) ; // Delay for a short moment
}

/***************************************************************************************************
                         void I2C_Write(uint8_t v_i2cData_u8)
 ***************************************************************************************************
 * I/P Arguments: uint8_t-->8bit data to be sent.
 * Return value  : none

 * description  :This function is used to send a byte on SDA line using I2C protocol
                 8bit data is sent bit-by-bit on each clock cycle.
                 MSB(bit) is sent first and LSB(bit) is sent at last.
                 Data is sent when SCL is low.

         ___     ___     ___     ___     ___     ___     ___     ___     ___     ___
 SCL:   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |
      __|   |___|   |___|   |___|   |___|   |___|   |___|   |___|   |___|   |___|   |___

 SDA:    D8       D7     D6      D5      D4       D3      D2      D1      D0     ACK


 ***************************************************************************************************/
void I2C_Write(void) // uint8_t v_i2cData_u8
{
    // TWDR = v_i2cData_u8 ;
    TWCR = ((1<< TWINT) | (1<<TWEN));
    while (!(TWCR & (1 <<TWINT)));
}

/***************************************************************************************************
                         uint8_t I2C_Read(uint8_t v_ackOption_u8)
****************************************************************************************************
 * I/P Arguments: none.
 * Return value  : uint8_t(received byte)

 * description :This fun is used to receive a byte on SDA line using I2C protocol.
               8bit data is received bit-by-bit each clock and finally packed into Byte.
               MSB(bit) is received first and LSB(bit) is received at last.


         ___     ___     ___     ___     ___     ___     ___     ___     ___     ___
SCL:    |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |
      __|   |___|   |___|   |___|   |___|   |___|   |___|   |___|   |___|   |___|   |__

 SDA:    D8       D7     D6      D5       D4     D3       D2      D1     D0      ACK


***************************************************************************************************/
uint8_t I2C_Read(uint8_t v_ackOption_u8)
{
    TWCR = ((1<< TWINT) | (1<<TWEN) | (v_ackOption_u8<<TWEA));
    while ( !(TWCR & (1 <<TWINT)));
    return TWDR;
}

int i2c_writebyte(unsigned int i2c_address, unsigned int dev_id,
					unsigned int dev_addr,char data) 
{
	unsigned char n = 0;
	unsigned char twi_status;
	char r_val = -1;
	
	i2c_retry:
		if (n++ >= MAX_TRIES) return r_val;
		
		// Transmit Start Condition
		twi_status=I2C_Start;
		
		// Check the TWI Status
		if (twi_status == TW_MT_ARB_LOST) goto i2c_retry;
		if ((twi_status != TW_START) && (twi_status != TW_REP_START)) goto i2c_quit;
		
		// Send slave address (SLA_W)
		TWDR = (dev_id & 0xF0) | ((dev_addr & 0x07) << 1) | TW_WRITE;
		I2C_Write();
	
		// Check the TWSR status
		if ((twi_status == TW_MT_SLA_NACK) || (twi_status == TW_MT_ARB_LOST)) goto i2c_retry;
		if (twi_status != TW_MT_SLA_ACK) goto i2c_quit;
		
		// Send the High 8-bit of I2C Address
		TWDR = i2c_address >> 8;
		I2C_Write();
		
		// Check the TWSR status
		if (twi_status != TW_MT_DATA_ACK) goto i2c_quit;
		
		// Send the Low 8-bit of I2C Address
		TWDR = i2c_address;
		I2C_Write();
		
		// Check the TWSR status
		if (twi_status != TW_MT_DATA_ACK) goto i2c_quit;
		
		// Put data into data register and start transmission
		TWDR = data;
		I2C_Write();
		
		// Check the TWSR status
		if (twi_status != TW_MT_DATA_ACK) goto i2c_quit;
		
		// TWI Transmit Ok
		r_val=1;

	i2c_quit:
		// Transmit I2C Data
		I2C_Stop();
		return r_val;
}


/*
int i2c_readbyte(unsigned int i2c_address, unsigned int dev_id,
					unsigned int dev_addr, char *data)
{
	unsigned char n = 0;
	unsigned char twi_status;
	char r_val = -1;

	i2c_retry:
		if (n++ >= MAX_TRIES) return r_val;
		
		// Transmit Start Condition
		twi_status=I2C_Start;

		// Check the TWSR status
		if (twi_status == TW_MT_ARB_LOST) goto i2c_retry;
		if ((twi_status != TW_START) && (twi_status != TW_REP_START)) goto i2c_quit;
		
		// Send slave address (SLA_W) 0xa0
		TWDR = (dev_id & 0xF0) | ((dev_addr << 1) & 0x0E) | TW_WRITE;
		I2C_Write();
		
		// Check the TWSR status
		if ((twi_status == TW_MT_SLA_NACK) || (twi_status == TW_MT_ARB_LOST)) goto i2c_retry;
		if (twi_status != TW_MT_SLA_ACK) goto i2c_quit;
		
		// Send the High 8-bit of I2C Address
		TWDR = i2c_address >> 8;
		I2C_Write();
		
		// Check the TWSR status
		if (twi_status != TW_MT_DATA_ACK) goto i2c_quit;

		// Send the Low 8-bit of I2C Address
		TWDR = i2c_address;
		I2C_Write();
		
		// Check the TWSR status
		if (twi_status != TW_MT_DATA_ACK) goto i2c_quit;  

		// Send start Condition
		I2C_Start();
		
		// Check the TWSR status
		if (twi_status == TW_MT_ARB_LOST) goto i2c_retry;
		if ((twi_status != TW_START) && (twi_status != TW_REP_START)) goto i2c_quit;
		
		// Send slave address (SLA_R)
		TWDR = (dev_id & 0xF0) | ((dev_addr << 1) & 0x0E) | TW_READ;
		I2C_Write();  

		// Check the TWSR status
		if ((twi_status == TW_MR_SLA_NACK) || (twi_status == TW_MR_ARB_LOST)) goto i2c_retry;
		if (twi_status != TW_MR_SLA_ACK) goto i2c_quit;
		
		// Read I2C Data
		I2C_Write();
		if (twi_status != TW_MR_DATA_NACK) goto i2c_quit;
		
		// Get the Data
		*data=TWDR;
		r_val=1;

	i2c_quit:
		// Send Stop Condition
		I2C_Stop();
		return r_val;
}

*/
//UNMODIFIED CODE ABOVE
int i2c_readbyte(char *data)
{
	unsigned char n = 0;
	unsigned char twi_status;
	char r_val = -1;

	i2c_retry:
		if (n++ >= MAX_TRIES) return r_val;
		
		// Transmit Start Condition
		twi_status=I2C_Start;

		// Check the TWSR status
		if (twi_status == TW_MT_ARB_LOST) goto i2c_retry;
		if ((twi_status != TW_START) && (twi_status != TW_REP_START)) goto i2c_quit;
		
		// Send slave address (SLA_W) 0xa0
		TWDR = (0b1101000) | TW_WRITE;
		I2C_Write();
		
		// Check the TWSR status
		if ((twi_status == TW_MT_SLA_NACK) || (twi_status == TW_MT_ARB_LOST)) goto i2c_retry;
		if (twi_status != TW_MT_SLA_ACK) goto i2c_quit;
		
		// Send the High 8-bit of I2C Address
		TWDR = 0x0C;
		I2C_Write();
		
		// Check the TWSR status
		if (twi_status != TW_MT_DATA_ACK) goto i2c_quit;  

		// Send start Condition
		I2C_Start();
		
		// Check the TWSR status
		if (twi_status == TW_MT_ARB_LOST) goto i2c_retry;
		if ((twi_status != TW_START) && (twi_status != TW_REP_START)) goto i2c_quit;
		
		// Send slave address (SLA_R)
		TWDR = (0b1101000) | TW_READ;
		I2C_Write();  

		// Check the TWSR status
		if ((twi_status == TW_MR_SLA_NACK) || (twi_status == TW_MR_ARB_LOST)) goto i2c_retry;
		if (twi_status != TW_MR_SLA_ACK) goto i2c_quit;
		
		// Read I2C Data
		I2C_Write();
		if (twi_status != TW_MR_DATA_NACK) goto i2c_quit;
		
		// Get the Data
		*data=TWDR;
		r_val=1;

	i2c_quit:
		// Send Stop Condition
		I2C_Stop();
		return r_val;
}

/*unsigned int i2c_address= 
unsigned int dev_id		=
unsigned int dev_addr	=*/
char a 		= 0xAA;
char *data	= &a;

int main(void)
{

	I2C_Init();		// Initialize the I2C module
	//I2C_Start();	// Starting the communication
	i2c_readbyte(data); // try to communicate with Bosch
	//TWSR=0x00; // set presca1er bits to 1 (0x00=1, 0x01=4, 0x02=16, 0x03=64)
    //TWBR=0x2A; // SCL frequency is 10K for 1Mhz; for now I'm not sure if this is optimal CHAD 0x2A
	//TWCR = ((1<<TWINT) | (1<<TWSTA) | (1<<TWEN));
    //while (!(TWCR & (1<<TWINT)));

	//TWDR = 0xAA;


	// Here we need to send the slave address, send some I2C data, and then go from there
	
}



